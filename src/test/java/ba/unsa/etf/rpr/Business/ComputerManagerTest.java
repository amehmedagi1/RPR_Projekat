package ba.unsa.etf.rpr.Business;

import ba.unsa.etf.rpr.Exceptions.GameException;
import ba.unsa.etf.rpr.dao.ComputerDaoSQLImpl;
import ba.unsa.etf.rpr.dao.DaoFactory;
import ba.unsa.etf.rpr.domain.Computer;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.mockito.Mockito.when;

public class ComputerManagerTest {
    private ComputerManager computerManager;
    private Computer computer;
    private ComputerDaoSQLImpl computerDaoSQLMock;
    private List<Computer> computers;

    @BeforeEach
    public void initialize(){
        computerManager = Mockito.mock(ComputerManager.class);
        computer = new Computer();
        computer.setId(50);
        computer.setCPU("testni");
        computer.setGPU("testni");
        computer.setRAM(50);
        computer.setMemory(150);
        computer.setGameID(2);
        computerDaoSQLMock = Mockito.mock(ComputerDaoSQLImpl.class);
        computers = new ArrayList<>();
        computers.addAll(Arrays.asList(new Computer("intel", "amd", 100, 16, 0), new Computer("intel i3", "intel integrated", 100, 16, 1)));


    }

    @Test
    void add() throws GameException{
        MockedStatic<DaoFactory> daoFactoryMockedStatic = Mockito.mockStatic(DaoFactory.class);
        daoFactoryMockedStatic.when(DaoFactory::computerDao).thenReturn(computerDaoSQLMock);
        when(DaoFactory.computerDao().getAll()).thenReturn(computers);
        Mockito.doCallRealMethod().when(computerManager).add(computer);
        GameException gameException = Assertions.assertThrows(GameException.class, ()->{
            computerManager.add(computer);}, "\"Computer id must be 0, because it's autogenerated");
        Assertions.assertEquals("Computer id must be 0, because it's autogenerated", gameException.getMessage());
        daoFactoryMockedStatic.verify(DaoFactory::computerDao);
        Mockito.verify(computerManager).add(computer);
        daoFactoryMockedStatic.close();
    }

    @Test
    void addToDB() throws GameException{
        computer.setId(0);
        computerManager.add(computer);
        Assertions.assertTrue(true);
        Mockito.verify(computerManager).add(computer);
    }

    @Test
    void validateComputer() throws GameException{
        Computer correct = new Computer("korektno", "korektno", 100, 8,0);
        try{
            Mockito.doCallRealMethod().when(computerManager).validateComputer(correct);
        }catch(GameException e){
            e.printStackTrace();
            Assertions.assertTrue(false);
        }

    }

    @Test
    void validateComputerIncorrect() throws GameException{
        Computer incorrect1 = new Computer("", "", 0, 0, 0);
        Mockito.doCallRealMethod().when(computerManager).validateComputer(incorrect1);
        GameException gameException1 = Assertions.assertThrows(GameException.class, ()->{
            computerManager.validateComputer(incorrect1);}, "Specifikacije moraju biti unesene");
        Assertions.assertEquals("Specifikacije moraju biti unesene", gameException1.getMessage());

        Computer incorrect2 = new Computer("nekiCPU", "", 15, 5, 0);
        Mockito.doCallRealMethod().when(computerManager).validateComputer(incorrect2);
        GameException gameException2 = Assertions.assertThrows(GameException.class, ()->{
            computerManager.validateComputer(incorrect1);}, "Specifikacije moraju biti unesene");
        Assertions.assertEquals("Specifikacije moraju biti unesene", gameException2.getMessage());

    }



}
